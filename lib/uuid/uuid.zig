// Modified from:
// https://github.com/dmgk/zig-uuid/blob/9895f72f67d463b6bd616cc63dcfe70d12dc53b9/uuid.zig

// Fast allocation-free v4 UUIDs.
// Inspired by the Go implementation at github.com/skeeto/uuid
const std = @import("std");

const fmt = std.fmt;
const crypto = std.crypto;
const Allocator = std.mem.Allocator;

pub const zero: [16]u8 = .{0} ** 16 ;

pub fn bin() [16]u8 {
	var uuid: [16]u8 = undefined;
	crypto.random.bytes(&uuid);
	return uuid;
}

pub fn hex() [36]u8 {
	var buf: [36]u8 = undefined;
	toString(bin(), &buf);
	return buf;
}

pub fn allocHex(allocator: Allocator) ![]u8 {
	var buf = try allocator.alloc(u8, 36);
	toString(bin(), buf);
	return buf;
}

pub fn toString(uuid: [16]u8, out: []u8) void {
	std.debug.assert(out.len == 36);
	const h = "0123456789abcdef";

	out[8] = '-';
	out[13] = '-';
	out[18] = '-';
	out[23] = '-';

	inline for (encoded_pos, 0..) |i, j| {
		out[i + 0] = h[uuid[j] >> 4];
		out[i + 1] = h[uuid[j] & 0x0f];
	}
}

pub fn parse(buf: []const u8) ![16]u8 {
	var uuid: [16]u8 = undefined;

	if (buf.len != 36 or buf[8] != '-' or buf[13] != '-' or buf[18] != '-' or buf[23] != '-') {
		return error.InvalidUUID;
	}

	inline for (encoded_pos, 0..) |i, j| {
		const hi = hex_to_nibble[buf[i + 0]];
		const lo = hex_to_nibble[buf[i + 1]];
		if (hi == 0xff or lo == 0xff) {
			return error.InvalidUUID;
		}
		uuid[j] = hi << 4 | lo;
	}
	return uuid;
}

// Indices in the UUID string representation for each byte.
const encoded_pos = [16]u8{ 0, 2, 4, 6, 9, 11, 14, 16, 19, 21, 24, 26, 28, 30, 32, 34 };

// Hex to nibble mapping.
const hex_to_nibble = [256]u8{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

const t = std.testing;
test "uuid: parse" {
	const uuids = [_][]const u8{
		"d0cd8041-0504-40cb-ac8e-d05960d205ec",
		"3df6f0e4-f9b1-4e34-ad70-33206069b995",
		"f982cf56-c4ab-4229-b23c-d17377d000be",
		"6b9f53be-cf46-40e8-8627-6b60dc33def8",
		"c282ec76-ac18-4d4a-8a29-3b94f5c74813",
		"00000000-0000-0000-0000-000000000000",
	};

	for (uuids) |uuid| {
		var out: [36]u8 = undefined;
		toString(try parse(uuid), &out);
		try t.expectEqualStrings(uuid, &out);
	}
}

test "uuid: invalid parse" {
	const uuids = [_][]const u8{
		"3df6f0e4-f9b1-4e34-ad70-33206069b99", // too short
		"3df6f0e4-f9b1-4e34-ad70-33206069b9912", // too long
		"3df6f0e4-f9b1-4e34-ad70_33206069b9912", // missing or invalid group separator
		"zdf6f0e4-f9b1-4e34-ad70-33206069b995", // invalid character
	};

	for (uuids) |uuid| {
			try t.expectError(error.InvalidUUID, parse(uuid));
	}
}

test "uuid: bin & hex" {
	{
		const uuid = bin();
		try t.expectEqual(@as(usize, 16), uuid.len);
	}

	for (0..10) |_| {
		const uuid = hex();
		var reversed: [36]u8 = undefined;
		toString(try parse(&uuid), &reversed);
		try t.expectEqualStrings(&uuid, &reversed);
	}
}

test "uuid: allocHex" {
	for (0..10) |_| {
		const uuid = try allocHex(t.allocator);
		defer t.allocator.free(uuid);
		var reversed: [36]u8 = undefined;
		toString(try parse(uuid), &reversed);
		try t.expectEqualStrings(uuid, &reversed);
	}
}
